---
title: "003_CIO_pipeline_integration"
date: last-modified
format:
  html:
    embed-resources: true
    code-tools: true
    code-overflow: wrap
editor: source
execute: 
  warning: false
  echo: false
  freeze: auto
toc: true
date-modified: last-modified
---

```{r}
#| echo: false
#| output: false
#| label: setup-chunk

#setup chunk

rm(list=ls()) ## removes existing files in environment

#libraries

library(dplyr)
library(Seurat)
library(patchwork)
library(SingleCellExperiment)
library(BiocManager)
library(ggplot2)
library(sctransform)
library(SeuratObject)
library(scater)
library(scran)
library(Matrix)
library(scDblFinder)
library(rmarkdown)
library(reshape2)
library(ggforce)
library(scRepertoire)
library(stringr)
library(SingleR)
library(nichenetr)
library(celldex)
library(glmGamPoi)
library(clustree)
library(dittoSeq)
library(Azimuth)

options(future.globals.maxSize = 2 * 1e9) ## set globals.maxSize to 2GB
set.seed(97)
cbf_3 <- dittoColors(reps = 10000, get.names=FALSE) ## generates a vector of color-blind friendly colors that we can use for visualizations
```

## Purpose

We will often need to combine multiple datasets together, which can lead to the dreaded batch effect. To investigate this, we will use data generated in the CIO from PBMCs from 3 different patients on a clinical trial and test different workflows for integration.

## Raw data vs Seurat objects

QC and doublet detection should be done on a per sample basis because QC metrics and doublet frequency may differ from sample to sample. We recommend performing the initial stages (creating a Seurat object, QC, doublet detection) on each sample separately, then merging. We have prepared Seurat objects and filtered out low quality cells and doublets already and will now load those objects. For this template, we will consider 3 samples from 3 patients (P5, P6, and P7).

```{r}
#| label: loading
#| output: false
#| echo: false

P5 <- LoadSeuratRds('/path/to/P5.rds')
P6 <- LoadSeuratRds('/path/to/P6.rds')
P7 <- LoadSeuratRds('/path/to/P7.rds')

## confirm that you have added metadata columns so you can easily separate different patients
## ex. P5$patient <- 'P5'

```

```{r}
#| label: merging
#| output: false
#| echo: false

## merge three objects

obj <- merge(x=P5,
             y=c(P6, P7), ## if you need to merge more than two objects, put one object in x and a list of the remaining objects in y
             add.cell.ids=c('P5', 'P6', 'P7')) ## adding prefixes to help distinguish which cell came from which patient
```

```{r}
#| label: SCTransform
#| output: false
#| echo: false

obj %>% ## this analysis is without integration
  SCTransform() %>%
  RunPCA(dims=1:30) %>%
  FindNeighbors(dims=1:30, reduction='pca') %>%
  FindClusters(resolution=0.3, cluster.name=c('unintegrated.0.3')) %>%
  RunUMAP(dims=1:30, reduction.name='unintegrated.umap') -> obj
```

## Unintegrated analysis

First, we will perform a standard SCTransform analysis on the merged object but without integration. @fig-unintegrated-umap shows a UMAP without integration, colored by cluster at resolution 0.3.

```{r}
#| label: fig-unintegrated-umap
#| fig-cap: 'UMAP without integration, grouped by clusters at resolution 0.3'

DimPlot(obj,
        reduction='unintegrated.umap', ## specifying which reduction to use, which is good practice when calculating multiple reductions
        group.by='unintegrated.0.3',
        cols=cbf_3,
        label=TRUE)
```
Are cells from the three patients well-mixed? @fig-umap-unintegrated-by-patient shows the same UMAP, now colored by patient. 

```{r}
#| label: fig-umap-unintegrated-by-patient
#| fig-cap: 'UMAP without integration, colored by patient'

DimPlot(obj,
        reduction='unintegrated.umap',
        group.by='patient',
        cols=cbf_3)
```
@fig-barplot-unintegrated-by-cluster quantifies the cells per patient in each cluster to help visualize mixing between patients.

```{r}
#| label: fig-barplot-unintegrated-by-cluster
#| fig-cap: 'Quantification of patient per cluster at resolution 0.3'

dittoBarPlot(obj,
             var='patient',
             group.by='unintegrated.0.3',
             retain.factor.levels=TRUE) + ylab('Proportion of cells')
```
## Integration

For integration, we will follow the Seurat integration vignettes available [here](https://satijalab.org/seurat/articles/seurat5_integration). Seurat offers five different methods of integration: we will try two different methods- anchor-based RPCA integration and Harmony.

```{r}
#| label: RPCA-integration
#| output: false
#| echo: false

obj %>%
  IntegrateLayers(method=RPCAIntegration,
                  normalization.method='SCT', ## we used SCTransform to normalize, so we need to specifically state that using 'normalization.method'
                  new.reduction='integrated.rpca') %>%
  FindNeighbors(dims=1:30,
                reduction='integrated.rpca') %>%
  FindClusters(resolution=0.3, cluster.name=c('rpca.0.3')) %>%
  RunUMAP(dims=1:30,
          reduction='integrated.rpca',
          reduction.name='rpca.umap') -> obj
```

```{r}
#| label: harmony-integration
#| output: false
#| echo: false

obj %>%
  IntegrateLayers(method=HarmonyIntegration,
                  normalization.method='SCT', ## we used SCTransform to normalize, so we need to specifically state that using 'normalization.method'
                  new.reduction='integrated.harmony') %>%
  FindNeighbors(dims=1:30,
                reduction='integrated.harmony') %>%
  FindClusters(resolution=0.3, cluster.name='harmony.0.3') %>%
  RunUMAP(dims=1:30,
          reduction='integrated.harmony',
          reduction.name='harmony.umap') -> obj
```

We will first look at RPCA integration. @fig-rpca-umap shows two UMAPs: on the left, colored by cluster and on the right, colored by patient.

```{r}
#| label: fig-rpca-umap
#| fig-cap: 'RPCA-integrated UMAPs, colored by cluster (left) and condition (right)'

DimPlot(obj,
        group.by='rpca.0.3',
        reduction='rpca.umap',
        cols=cbf_3) | DimPlot(obj,
                              group.by='patient',
                              reduction='rpca.umap',
                              cols=cbf_3)
```

Next, @fig-harmony-umap shows a similar figure for Harmony integration: on the left, colored by cluster and on the right, colored by patient.

```{r}
#| label: fig-harmony-umap
#| fig-cap: 'Harmony-integrated UMAPs, colored by cluster (left) and condition (right)'

DimPlot(obj,
        group.by='harmony.0.3',
        reduction='harmony.umap',
        cols=cbf_3) | DimPlot(obj,
                              group.by='patient',
                              reduction='harmony.umap',
                              cols=cbf_3)
```
@fig-barchart-rpca-patient-by-cluster quantifies cells per patient by RPCA cluster.

```{r}
#| label: fig-barchart-rpca-patient-by-cluster
#| fig-cap: 'Quantification of patient per cluster after RPCA integration'

dittoBarPlot(obj,
             var='patient',
             group.by='rpca.0.3',
             retain.factor.levels=TRUE) + ylab('Proportion of cells')
```
@fig-barchart-harmony-patient-by-cluster shows a similar analysis for Harmony integration.

```{r}
#| label: fig-barchart-harmony-patient-by-cluster
#| fig-cap: 'Quantification of patient per cluster after harmony integration'

dittoBarPlot(obj,
             var='patient',
             group.by='harmony.0.3',
             retain.factor.levels=TRUE) + ylab('Proportion of cells')
```


## Conclusions

If you are working with multiple samples, it is essential to compare unintegrated to integrated data. From examining unintegrated data (@fig-umap-unintegrated-by-patient), we can usually see some separation between different samples, particularly when working with different patients, motivating us to try integration. Here, we show both RPCA and Harmony integration: the Seurat vignette considers RPCA to be more conservative (less correction) than is Harmony.

```{r}
#| label: saving
#| output: false
#| echo: false

SaveSeuratRds(obj, file='003_CIO_pipeline_integration.rds')
```

