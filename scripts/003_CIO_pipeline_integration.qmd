---
title: "003_CIO_pipeline_integration"
date: last-modified
format:
  html:
    embed-resources: true
    code-tools: true
    code-overflow: wrap
editor: source
execute: 
  warning: false
  echo: false
  freeze: auto
toc: true
date-modified: last-modified
---

```{r}
#| echo: false
#| output: false
#| label: setup-chunk

#setup chunk

rm(list=ls()) ## removes existing files in environment

#libraries

library(dplyr)
library(Seurat)
library(patchwork)
library(SingleCellExperiment)
library(BiocManager)
library(ggplot2)
library(sctransform)
library(SeuratObject)
library(scater)
library(scran)
library(Matrix)
library(scDblFinder)
library(rmarkdown)
library(reshape2)
library(ggforce)
library(scRepertoire)
library(stringr)
library(SingleR)
library(nichenetr)
library(celldex)
library(glmGamPoi)
library(clustree)
library(dittoSeq)
library(Azimuth)

options(future.globals.maxSize = 2 * 1e9) ## set globals.maxSize to 2GB
set.seed(97)
cbf_3 <- dittoColors(reps = 10000, get.names=FALSE) ## generates a vector of color-blind friendly colors that we can use for visualizations
```

## Purpose

We will often need to combine multiple datasets together, which can lead to the dreaded batch effect. To investigate this, we will use data generated in the CIO from PBMCs from 3 different patients on a clinical trial and test different workflows for integration.

## Raw data vs Seurat objects

QC and doublet detection should be done on a per sample basis because QC metrics and doublet frequency may differ from sample to sample. We recommend performing the initial stages (creating a Seurat object, QC, doublet detection) on each sample separately, then merging. We have prepared Seurat objects and filtered out low quality cells and doublets already and will now load those objects.

```{r}
#| label: loading
#| output: false
#| echo: false

P5 <- LoadSeuratRds('/data/NCI-CIO/prinsds/CIO_pipeline_files/VB_003_files/VB_003_P5_tomerge_v2.rds')
P6 <- LoadSeuratRds('/data/NCI-CIO/prinsds/CIO_pipeline_files/VB_003_files/VB_003_P6_tomerge_v2.rds')
P7 <- LoadSeuratRds('/data/NCI-CIO/prinsds/CIO_pipeline_files/VB_003_files/VB_003_P7_tomerge_v2.rds')

## confirm that you have added metadata columns so you can easily separate different patients
## ex. P5$patient <- 'P5'

```

```{r}
#| label: merging
#| output: false
#| echo: false

## merge three objects

obj <- merge(x=P5,
             y=c(P6, P7), ## if you need to merge more than two objects, put one object in x and a list of the remaining objects in y
             add.cell.ids=c('P5', 'P6', 'P7')) ## adding 'd' or 'h' to cell names as another way to distinguish cells
```

```{r}
#| label: SCTransform
#| output: false
#| echo: false

obj %>% ## this analysis is without integration
  SCTransform() %>%
  RunPCA(dims=1:30) %>%
  FindNeighbors(dims=1:30, reduction='pca') %>%
  FindClusters(resolution=0.3, cluster.name=c('unintegrated.0.3')) %>%
  RunUMAP(dims=1:30, reduction.name='unintegrated.umap') -> obj
```

## Unintegrated analysis

First, we will perform a standard SCTransform analysis on the merged object but without integration. @fig-unintegrated-umap shows a UMAP without integration, colored by cluster at resolution 0.3, showing 17 different clusters.

```{r}
#| label: fig-unintegrated-umap
#| fig-cap: 'UMAP without integration, grouped by clusters at resolution 0.3'

DimPlot(obj,
        reduction='unintegrated.umap', ## specifying which reduction to use, which is good practice when calculating multiple reductions
        group.by='unintegrated.0.3',
        cols=cbf_3,
        label=TRUE)
```
Are cells from the three patients well-mixed? @fig-umap-unintegrated-by-patient shows the same UMAP, now colored by patient. We see good mixing in some areas, but some areas seem to mostly contain cells from a single patient.

```{r}
#| label: fig-umap-unintegrated-by-patient
#| fig-cap: 'UMAP without integration, colored by patient'

DimPlot(obj,
        reduction='unintegrated.umap',
        group.by='patient',
        cols=cbf_3)
```
@fig-barplot-unintegrated-by-cluster quantifies the cells per patient in each cluster. While each cluster contains some cells from each patient, there are some clusters that are disproportionately represented by a single patient: see cluster 3 in particular. This indicates that integration is likely necessary for this dataset.

```{r}
#| label: fig-barplot-unintegrated-by-cluster
#| fig-cap: 'Quantification of patient per cluster at resolution 0.3'

dittoBarPlot(obj,
             var='patient',
             group.by='unintegrated.0.3',
             retain.factor.levels=TRUE) + ylab('Proportion of cells')
```
## Integration

For integration, we will follow the Seurat integration vignettes available at https://satijalab.org/seurat/articles/seurat5_integration. Seurat offers five different methods of integration: we will try two different methods- anchor-based RPCA integration and Harmony.

```{r}
#| label: RPCA-integration
#| output: false
#| echo: false

obj %>%
  IntegrateLayers(method=RPCAIntegration,
                  normalization.method='SCT', ## we used SCTransform to normalize, so we need to specifically state that using 'normalization.method'
                  new.reduction='integrated.rpca') %>%
  FindNeighbors(dims=1:30,
                reduction='integrated.rpca') %>%
  FindClusters(resolution=0.3, cluster.name=c('rpca.0.3')) %>%
  RunUMAP(dims=1:30,
          reduction='integrated.rpca',
          reduction.name='rpca.umap') -> obj
```

```{r}
#| label: harmony-integration
#| output: false
#| echo: false

obj %>%
  IntegrateLayers(method=HarmonyIntegration,
                  normalization.method='SCT', ## we used SCTransform to normalize, so we need to specifically state that using 'normalization.method'
                  new.reduction='integrated.harmony') %>%
  FindNeighbors(dims=1:30,
                reduction='integrated.harmony') %>%
  FindClusters(resolution=0.3, cluster.name='harmony.0.3') %>%
  RunUMAP(dims=1:30,
          reduction='integrated.harmony',
          reduction.name='harmony.umap') -> obj
```

We will first look at RPCA integration. @fig-rpca-umap shows two UMAPs: on the left, colored by cluster and on the right, colored by condition.

```{r}
#| label: fig-rpca-umap
#| fig-cap: 'RPCA-integrated UMAPs, colored by cluster (left) and condition (right)'

DimPlot(obj,
        group.by='rpca.0.3',
        reduction='rpca.umap',
        cols=cbf_3) | DimPlot(obj,
                              group.by='patient',
                              reduction='rpca.umap',
                              cols=cbf_3)
```

Next, @fig-harmony-umap shows a similar figure for Harmony integration: on the left, colored by cluster and on the right, colored by condition.

```{r}
#| label: fig-harmony-umap
#| fig-cap: 'Harmony-integrated UMAPs, colored by cluster (left) and condition (right)'

DimPlot(obj,
        group.by='harmony.0.3',
        reduction='harmony.umap',
        cols=cbf_3) | DimPlot(obj,
                              group.by='patient',
                              reduction='harmony.umap',
                              cols=cbf_3)
```
Visually, it appears that mixing is improved for both RPCA and Harmony integration. To quantify this, @fig-barchart-rpca-patient-by-cluster quantifies cells per patient by RPCA cluster. Mixing appears to be better than without integration, but there are certainly still some clusters that are disproportionately from a single patient (ex cluster 17).

```{r}
#| label: fig-barchart-rpca-patient-by-cluster
#| fig-cap: 'Quantification of patient per cluster after RPCA integration'

dittoBarPlot(obj,
             var='patient',
             group.by='rpca.0.3',
             retain.factor.levels=TRUE) + ylab('Proportion of cells')
```
@fig-barchart-harmony-patient-by-cluster shows a similar analysis for Harmony integration, again showing improved mixing between patients as compared to unintegrated data.

```{r}
#| label: fig-barchart-harmony-patient-by-cluster
#| fig-cap: 'Quantification of patient per cluster after harmony integration'

dittoBarPlot(obj,
             var='patient',
             group.by='harmony.0.3',
             retain.factor.levels=TRUE) + ylab('Proportion of cells')
```


## Conclusions

If you are working with multiple samples, it is essential to compare unintegrated to integrated data. From examining unintegrated data (@fig-umap-unintegrated-by-patient), we can clearly see some separation between patients, motivating us to try integration. Both RPCA and Harmony integration improved mixing between the three patients and significantly reduced the presence of patient-specific clusters. We do not see huge differences between RPCA and Harmony integration from this basic view of the data: you can test using either or both of these integration methods. The Seurat vignette considers RPCA to be more conservative (less correction) than is Harmony. Note that this dataset has minimal batch effects, as these three samples were processed and captured in parallel: you would expect to see stronger differences from sample-to-sample if you are combining samples from captures that were done on different days/by different people/with different technologies/etc.

```{r}
#| label: saving
#| output: false
#| echo: false

SaveSeuratRds(obj, file='003_CIO_pipeline_integration.rds')
```

